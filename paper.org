#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t
#+OPTIONS: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:t e:t

#+OPTIONS: email:nil f:t inline:t num:t p:nil pri:nil prop:nil stat:t tags:t
#+OPTIONS: tasks:t tex:t timestamp:t title:t toc:t todo:t |:t
#+TITLE: The Pólya-Vinogradov inequality and the distribution of quadratic residues mod p
#+DATE: <2017-03-19 Sun>
#+AUTHOR: MATH 471 - Sam Gwydir
#+EMAIL: sgwydir@C02NW52ZG3QD.group.on
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 25.2.1 (Org mode 9.0.5)

\pagebreak
* Notes                                                            :noexport:
** Legendre Symbol
   - (a/p) = 1 if a is a quad res mod p and not 0
   - (a/p) = -1 if a is a quad non-res mod p
   - (a/p) = 0 if a = 0 mod p
   - (a/p) = a^((p-1)/2) (mod p)
** Polya & Vinogradov
  - http://planetmath.org/sites/default/files/texpdf/33084.pdf
  - Shows that the number of quadratic residues modulo q in any interval of
    length N is N/2 + O(\sqrt{p}log(p)) 
  - https://www.cs.umd.edu/~gasarch/TOPICS/res/burgess.pdf
  - https://terrytao.wordpress.com/tag/polya-vinogradov-inequality/
** Futhur Work
   - Assuming generalized Riemann hypothesis, Montogomery and Vaughan have shown O(\sqrt{N}\log{}\log{}N) in 1977
   - Montogmery and Vaughan cannot be substantially improved because Schur (1918) and Paley (1932)
   - https://en.wikipedia.org/wiki/Quadratic_residue#The_P.C3.B3lya.E2.80.93Vinogradov_inequality
** Questions
*** TODO How random is the sequence of \pm1 generated by legendre(n,p) for large p?
*** TODO How can we optimize calculation of legendre symbols?
    - https://math.stackexchange.com/questions/447468/fast-legendre-symbol-calculation
*** TODO How can we test/measure randomness?
    - NIST Statistical Test Suite
    - Die Harder
*** DONE What libraries did Tyler use?
    CLOSED: [2017-03-19 Sun 08:51]
    - GMP
    - NTL


* Introduction
  Generating random numbers is an important problem in computer science and
  applied mathematics and in particular, in cryptography. Many cryptographic
  algorithms depend on the users' ability to generate random numbers including
  generating keys for one-time pads or testing primality via Miller-Rabin,
  Solovay-Strassen or the Fermat primality test. While sources of "true" random
  numbers exist, such as measuring atmospheric or thermal noise, these sources
  are limited in the amount of entropy they can provide and therefore bottleneck
  the speed of routines which make use of them [fn:2]. Thus most systems use
  "pseudo" random number generation which generate a seemingly random sequence
  of numbers that is "hard" to determine without knowing a secret key, or seed.
  Therefore finding methods of pseudo random number generation is of great
  interest to students of cyptography.

  
  Cryptography makes great use of the concept of the quadratic residue in a
  variety of applications. An integer q is a quadratic residue mod p if there is
  another integer x such that $x^{2}\equiv{}q \pmod{p}$ [fn:3]. To date, the
  distribution of quadratic residues and non-residues is an open problem, though
  several bounds concerning the number of quadratic residues have been
  developed. In 1918, Pólya and Vinogradov independently showed that
  $\left(\frac{n}{p}\right)$ for consecutive values of n can be seen as random
  coin flips with values of $\pm1$. In particular they showed on an interval of
  length N, the number of consecutive quadratic residues modulo p is
  $$\frac{1}{2}N+O\left(\sqrt{p}\log{p}\right)$$. Thus we can state
  $$\left|{\sum\limits_{n=M+1}^{M+N} {\left(\frac{n}{p}\right)}}\right| <
  \sqrt{p}\log{p}$$ which gives us a bound on the number of identical
  consecutive "coin tosses". In the following short paper we will investigate
  how "random" this sequence is, how we can best compute these values and what
  other related bounds exist.

** notes                                                           :noexport:
  - Not much is known about the distribution of quadratic residues and non
    residues from 1 to p-1 (mod p)[fn:1] 
  - Polya and Vinogradov independently showed that (n|p) on n = 1 - p-1 for
    large primes p is somewhat of a random sequnce 
    - specifically that the number of quad res mod q on an interval of length q
      is N/2 + O(\sqrt{p}log(p)) 
  - We would like to evaluate this sequence's performance as a pseudo random
    number generator 
    - How well would this perform compared to other PRNG?
      - Can we optimize the computations?
* Motivation                                                       :noexport:
  - PRNG is very important in computing since sources of "true" randomness are cumbersome and slow
  - 
* Methodology                                                      :noexport:
  - program in here
  - NTL/GMP
  - Calculate all quadratic residues
* Pólya-Vinogradov Inequality
  First we must evaluate what the Pólya-Vinogradov Inequality tells us. This
  inequality can be interpreted as a measure of the "statistical fluctuation" of
  the number of quadratic residues and non residues in the sequence of Legendre
  symbols on a prime p. In particular the inequality says
  that this count is bounded by $\sqrt{p}\log{p}$, though for p large, this
  becomes $\sqrt{p}$. In addition we know from the inequality that in an
  interval of length N, there are $$\frac{1}{2}N+O\left(\sqrt{p}\log{p}\right)$$ consecutive
  quadratic residues $\pmod p$. Thus we know the least quadratic
  non-residue $\pmod p$, is bounded above by $O(\sqrt{p}\log{p})$ [fn:4].

  Notably Montgomery and Vaughan (1977) showed that if we assume the truth of
  the Generalized Riemann Hypothesis then the estimate of the character sum
  above becomes $O(\sqrt{p}\log{\log{p}})$ [fn:5]

  But, even without assuming unproved conjectures we can achieve a finer result,
  though not substantially. In 1987 Cochrane obtained that
  $$\left|{\sum\limits_{n=M+1}^{M+N} {\left(\frac{n}{p}\right)}}\right| <
  \frac{4}{\pi{}^2}\sqrt{p}\log{p}+0.41\sqrt{p}+0.61 $$.

  In the following paragraphs we will compare the real world results against
  these bounds. 
* Findings
** Computing Quadratic Residues
   The Legendre symbol is defined as[fn:6]: $$\left(\frac{a}{p}\right) =
   a^{\frac{p-1}{2}} \pmod p =
   \begin{cases}
    1 & \text{ if } a \text{ is a quadratic residue modulo } p \text{ and } a \not\equiv 0\pmod{p}, \\
   -1 & \text{ if } a \text{ is a quadratic non-residue modulo } p, \\
    0 & \text{ if } a \equiv 0 \pmod{p}.  
   \end{cases}$$ This indicates if we were to naively evaluate the sum in the
   Pólya-Vinogradov inequality it would be made up of 3 values namely, 0, 1 and -1.
   This would require a modular exponentiation which are expensive. Obviously (and at the suggestion of the professor) this is not the direction
   to go first. 

   Firstly when evaluating the sum we will choose a range from $1$ to $N$ for
   some $N > 1$. Now instead of calculating the Legendre symbol, we can directly
   find the quadratic residues in this range by squaring the numbers in the
   interval $\frac{p-1}{2}$ taken $\pmod p$. If our interval from $1$ to $N$ is
   smaller than $p$ we know there are no zeroes, thus all other values are $-1$.
   If this interval is larger than $p$, we leverage the fact that the Legendre
   symbol is periodic in p. Finding the quadratic residues is the same as before
   but we should then find the first integer in our interval, n such that $n|p$.
   We can then create an array the size of our interval, and place a zero at
   this index. After this index we can fill in the values
   $1^2...{\frac{p-1}{2}}^2, 0$ repeating until the array is filled. 

   However, if we are taking some random interval in $1...$ that doesn't contain
   an $n$ that divides $p$ then we can just directly calculate the Legendre
   symbol. To speed up our calculations we should not use the direct calculation
   using a modular exponentiation but instead use the supplements to the law of
   quadratic reciprocity like one would do when evaluating a Legendre symbol by
   hand. This means pulling off powers of 2 from $a$ in
   $\left(\frac{a}{p}\right)$ then we have
   $\left(\frac{2^n}{p}\right)\left(\frac{a}{p}\right)$ and using the law of
   quadratic reciprocity to simplify our calculations. This is exactly what is
   done in Victor Shoup's NTL library.

   Provided we can do this we can quickly return blocks of coin flips quickly.
   Note carefully that this sequence will repeat on p, thus if this algorithm
   were to be used as a pseudorandom number generator such as ~/dev/random~ on
   UNIX systems, then a new p should be found each time a 0 is reached in a
   sequence.

** Randomness of sequence
   We've discussed how to implement a pseudorandom number generator using this
   inequality and implied that it is random, but we should quantify the quality
   of our pseudorandom number generator. 

   I will be using the DIEHARDER random number test suite to evaluate the
   randomness of using the legendre sequence as a pseudorandom number
   generator[fn:7]. I will make use of the bitstream test to evaluate the
   stream. It should be noted that I am generating all values from $1..(p-1)$
   and then assigning values of $-1$ to $0$, since we won't have any zeroes from
   the Legendre symbols and a stream of only zeroes and ones is allowed into the
   test, this should be suitable for our purposes.

   #+begin_quote
The bitstream test: The file under test is viewed as a stream of bits. Call them
b1, b2, ... . Consider an alphabet with two "letters", 0 and 1 and think of the
stream of bits as a succession of 20-letter "words", overlapping. Thus the first
word is b1b2...b20, the second is b2b3...b21, and so on. The bitstream test
counts the number of missing 20-letter (20-bit) words in a string of 2^21
overlapping 20-letter words. There are 2^20 possible 20-letter words. For a truly
random string of 2^21 + 19 bits, the number of missing words j should be (very
close to) normally distributed with mean 141,909 and sigma 428. Thus (j −
141909)/428 should be a standard normal variate (z score) that leads to a
uniform [0,1) p value. The test is repeated twenty times.
#+end_quote

  Here is the code we use the generate the sequence:

#+begin_src cpp
#include <iostream>
#include <gmpxx.h>
#include <NTL/ZZ.h>
#include <NTL/ZZ_p.h>

// From NTL
int Legendre(const NTL::ZZ& aa, const NTL::ZZ& nn)
{
  NTL::ZZ a, n;
  long t, k;
  long d;

  a = aa;
  n = nn;
  t = 1;

  while (a != 0) {
    k = MakeOdd(a);
    d = trunc_long(n, 3);
    if ((k & 1) && (d == 3 || d == 5)) t = -t;

    if (trunc_long(a, 2) == 3 && (d & 3) == 3) t = -t;
    swap(a, n);
    rem(a, a, n);
  }

  if (n == 1)
    return t;
  else
    return 0;
}

int main(int argc, char *argv[])
{

  // set the number of bits in our modulus using first argument of program
  int numbit = atoi(argv[1]);

  // generate prime of numbits
  NTL::ZZ p = NTL::GenPrime_ZZ(numbit);
  NTL::ZZ_p::init(p);

  // set our range using second and third argument of program
  NTL::ZZ m = NTL::ZZ(0);
  NTL::ZZ n = p -1;

  // optionally on command line
  // NTL::ZZ m = NTL::ZZ(atoi(argv[2]));
  // NTL::ZZ n = NTL::ZZ(atoi(argv[3]));

  for (NTL::ZZ i = NTL::ZZ(m + 1); i <= (n+m); ++i) {
    // std::cout << i << "\t" << NTL::Jacobi(i, p) << std::endl;
    // std::cout << NTL::Jacobi(i, p) << std::endl;
    unsigned int j = Legendre(i, p);
    if (j == (unsigned int)-1) std::cout << "0";
    else std::cout << "1";
  }
  return 0;
}

#+end_src

We then run this through dieharder to evaluate a number of times to evaluate
whether or not the p-values are normally distributed from 0 to 1.

#+begin_src sh
./polya 512 | dieharder -d 4 | tail -n 1  | cut -d'|' -f5
#+end_src


#+CAPTION: Distribution of p-values from DIEHARDER bitstream_test (graphed in Mathematica)
[[/Users/sgwydir/Dropbox/School/MATH471/PROJ1/dist.png]]

Running this 500 times we see that the p-values are mostly evenly distributed,
but there are more on the higher side indicating that improvements could be
made and perhaps the raw Legendre sequence is not a perfect fit for a pseudo
random number generator.
* Future Work
  In "On the Randomness of Legendre and Jacobi Sequences" Damgard (1998)
  suggests that Jacobi symbols generate stronger randomness properties than a
  Legendre sequence. This is worth exploring. 

* Footnotes

[fn:7] http://www.phy.duke.edu/~rgb/General/dieharder.php

[fn:6] https://en.wikipedia.org/wiki/Legendre_symbol

[fn:5] https://en.wikipedia.org/wiki/Generalized_Riemann_hypothesis

[fn:4] http://thales.doa.fmph.uniba.sk/macaj/skola/teoriapoli/primes.pdf

[fn:3] https://en.wikipedia.org/wiki/Quadratic_residue

[fn:2] https://en.wikipedia.org/wiki/Random_number_generation#Practical_applications_and_uses

[fn:1] https://pdfs.semanticscholar.org/5408/e45b12f54cbf584fd58620df4b28ed23e76c.pdf

